<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="bot-title">Aether AI</title>
    <!-- SEO and Embedding Improvements -->
    <meta name="description" content="Aether AI: Your intelligent assistant for any query.">
    <meta property="og:title" content="Aether AI">
    <meta property="og:description" content="An intelligent, conversational AI assistant.">
    <meta property="og:image" content="https://html-generator.com/uploads/images/2025/09/23/36475G8PAZQLZ5Z.png">
    
    <link rel="icon" type="image/png" href="https://html-generator.com/uploads/images/2025/09/23/36475G8PAZQLZ5Z.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- External Libraries for Markdown, Sanitization, and Code Highlighting -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@2.3.8/dist/purify.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-one-light.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <style>
        /* --- âœ¨ NEW PROFESSIONAL LIGHT THEME --- */
        :root {
            --background-start: #f4f7fa;
            --background-end: #ffffff;
            --text-primary: #1f2937;
            --text-secondary: #4b5563;
            --user-bubble-start: #2563eb;
            --user-bubble-end: #1d4ed8;
            --bot-bubble-bg: #ffffff;
            --bot-bubble-border: #e5e7eb;
            --input-background: #ffffff;
            --accent-glow: rgba(59, 130, 246, 0.3);
            --code-bg: #f9fafb;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-8px); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        body { 
            font-family: 'Inter', sans-serif; 
            background: linear-gradient(180deg, var(--background-start), var(--background-end));
            color: var(--text-primary);
        }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 4px;}
        ::-webkit-scrollbar-thumb:hover { background: #9ca3af; }

        #welcome-logo {
            animation: float 6s ease-in-out infinite;
        }

        #chat-input {
            resize: none;
            scrollbar-width: none;
        }
        #chat-input::-webkit-scrollbar {
            display: none;
        }
        
        .message-group {
            display: flex;
            gap: 1rem;
            max-width: 85%;
            align-items: flex-start;
            animation: fadeIn 0.5s ease-out forwards;
        }
        .message-group.user {
            align-self: flex-end;
            flex-direction: row-reverse;
        }
        .message-group.bot {
            align-self: flex-start;
        }
        
        .bot .messages-container {
            border-radius: 1.25rem;
            border-top-left-radius: 0.5rem;
            overflow: hidden;
        }

        .messages-container:hover .message-actions, .message-content:hover .message-actions {
            opacity: 1;
        }

        .message-actions {
            position: absolute;
            bottom: -5px;
            display: flex;
            gap: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            z-index: 10;
        }
        .bot .message-actions {
            right: 5px;
        }
        .user .message-actions {
            right: -15px; /* Reverted to original positioning */
        }

        .action-btn {
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 9999px;
            padding: 0.25rem;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.2s;
        }
        .action-btn:hover {
            background-color: #f3f4f6;
            color: var(--text-primary);
            transform: scale(1.1);
        }

        .message-content {
            padding: 0.85rem 1.35rem;
            word-wrap: break-word;
            line-height: 1.6;
            white-space: pre-wrap;
            position: relative; /* Needed for action buttons */
        }
        .message-content > *:first-child { margin-top: 0; }
        .message-content > *:last-child { margin-bottom: 0; }
        
        .message-content p {
            margin-bottom: 0.5rem; 
        }
        .message-content a {
            color: #2563eb;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s;
        }
        .message-content a:hover {
            text-decoration: underline;
        }
        .message-content .contact-link, .message-content .external-link {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            text-decoration: none !important;
        }
        .message-content .contact-link {
            background-color: #f0f5fe;
            border: 1px solid #dbeafe;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            color: #3b82f6;
        }
        .message-content .contact-link:hover {
            background-color: #dbeafe;
        }

        .message-content ul {
            list-style: none;
            padding: 0;
            margin: 0.25rem 0; /* FIX: Reduced vertical margin to remove extra space */
        }
        .message-content li {
            display: flex;
            align-items: center; /* FIX: Changed from flex-start to center for vertical alignment */
            gap: 0.75rem;
            padding: 0.3rem 0.25rem; /* FIX: Further reduced vertical padding */
            border-bottom: 1px solid #f3f4f6;
        }
        .message-content li:last-child {
            border-bottom: none;
        }
        .message-content li i {
            flex-shrink: 0;
            /* REMOVED: margin-top: 0.2rem; No longer needed with align-items: center */
            color: var(--user-bubble-start);
        }
        
        .user .message-content {
            background: linear-gradient(135deg, var(--user-bubble-start), var(--user-bubble-end));
            color: white;
            border-radius: 1.25rem;
            border-bottom-right-radius: 0.5rem;
        }
        .bot .message-content {
            background: var(--bot-bubble-bg);
            border: 1px solid var(--bot-bubble-border);
            box-shadow: 0 4px 12px -2px rgba(0,0,0,0.05);
            color: var(--text-primary);
        }

        .bot-avatar {
            flex-shrink: 0;
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 9999px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #60a5fa, #3b82f6);
            box-shadow: 0 0 15px -3px var(--accent-glow);
        }
        
        .bot .image-container {
            max-width: 320px;
            margin-top: 0.5rem;
        }
         .bot .image-container img {
            display: block;
            width: 100%;
            border-radius: 0.75rem;
        }

        .bot .content-button { 
            display: flex; align-items: center; justify-content: center; gap: 0.5rem; width: 100%; text-align: center;
            background: #f9fafb;
            padding: 12px 15px; color: #374151; font-weight: 600;
            transition: all 0.2s ease-in-out;
            border-top: 1px solid #f3f4f6;
        }
        .bot .content-button:hover { 
            background: #f3f4f6;
            color: var(--text-primary);
        }


        .message-content table { 
            font-size: 0.875rem; 
            width: 100%; 
            border-collapse: separate; 
            border-spacing: 0;
            border: 1px solid #f3f4f6;
            border-radius: 0.75rem;
            overflow: hidden;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .bot .message-content table {
            background-color: transparent;
        }
        .message-content table td, .message-content table th { 
            padding: 10px 14px; 
            text-align: left; 
            border-bottom: 1px solid #f3f4f6;
        }
         .message-content table tr:last-child td {
            border-bottom: none;
        }
        .message-content table th { 
            background-color: #f9fafb;
            font-weight: 600;
        }
        
        .suggestion-chip {
            transition: all 0.2s;
            background-color: var(--input-background);
            color: var(--text-secondary);
            border: 1px solid #e5e7eb;
            box-shadow: 0 2px 4px rgba(0,0,0,0.03);
        }
        .suggestion-chip:hover {
            background-color: #f9fafb;
            color: var(--text-primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
            border-color: #d1d5db;
        }
        
        .typing-indicator span {
            height: 8px;
            width: 8px;
            background-color: #9ca3af;
            border-radius: 50%;
            display: inline-block;
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .typing-indicator span:nth-of-type(1) { animation-delay: -0.32s; }
        .typing-indicator span:nth-of-type(2) { animation-delay: -0.16s; }
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1.0); }
        }

        #send-btn {
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            background: linear-gradient(135deg, var(--user-bubble-start), var(--user-bubble-end));
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -2px rgba(0, 0, 0, 0.05);
        }
        #send-btn:hover:not(:disabled) {
            transform: scale(1.1);
            box-shadow: 0 10px 15px -3px var(--accent-glow), 0 4px 6px -4px var(--accent-glow);
        }
        #send-btn:active:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }
        
        .message-content pre[class*="language-"] {
            background: var(--code-bg);
            border-radius: 0.75rem;
            padding: 1rem;
            margin: 0.5rem 0;
            overflow: auto;
            border: 1px solid #e5e7eb;
        }
        .input-wrapper {
            transition: all 0.3s ease-in-out;
            background: var(--input-background);
            border-radius: 1rem;
            border: 1px solid #d1d5db;
            box-shadow: 0 4px 12px -4px rgba(0,0,0,0.05);
        }
        .input-wrapper:focus-within {
            box-shadow: 0 0 0 3px var(--accent-glow);
            border-color: #3b82f6;
        }
    </style>
</head>
<body class="flex flex-col h-screen">
    
    <main id="chat-container" class="flex-1 overflow-y-auto p-4 md:p-6">
        <div id="chat-messages" class="max-w-3xl mx-auto flex flex-col space-y-6">
            <!-- Welcome screen, shown only at the start -->
            <div id="welcome-screen" class="text-center py-16">
                <div class="inline-block rounded-full mb-6 relative p-2">
                    <div class="absolute inset-0 bg-gradient-to-br from-blue-400 to-indigo-600 rounded-full blur-xl opacity-50"></div>
                    <img id="welcome-logo" src="https://html-generator.com/uploads/images/2025/09/23/36475G8PAZQLZ5Z.png" class="w-16 h-16 relative z-10 rounded-full" alt="Company Logo">
                </div>
                <h1 id="welcome-header" class="text-4xl md:text-5xl font-bold text-gray-800">Welcome to Aether AI</h1>
                <p class="text-gray-500 mt-3 text-lg">Your intelligent assistant for any query.</p>
            </div>
            <!-- Chat messages will be appended here -->
        </div>
    </main>

    <footer class="p-4 bg-transparent">
        <div class="max-w-3xl mx-auto">
            <!-- "Stop Generating" button, shown only when the bot is responding -->
            <div id="stop-generating-container" class="flex justify-center mb-2 hidden">
                <button id="stop-generating-btn" class="flex items-center gap-2 px-4 py-2 border border-gray-300 rounded-lg text-gray-600 hover:bg-gray-100">
                    <i data-lucide="square" class="w-4 h-4"></i> Stop generating
                </button>
            </div>
            <!-- Suggestion chips for user guidance -->
            <div id="suggestion-chips" class="flex flex-wrap gap-2 mb-3 justify-center hidden"></div>
            <!-- Main input area -->
            <div class="input-wrapper relative flex items-end p-1.5">
                <textarea id="chat-input" placeholder="Ask anything..." class="flex-1 bg-transparent px-4 py-2 border-none focus:outline-none focus:ring-0 text-gray-800 placeholder-gray-500" rows="1"></textarea>
                <button id="send-btn" class="text-white rounded-full p-3 flex-shrink-0 disabled:opacity-50 disabled:cursor-not-allowed ml-2">
                    <i data-lucide="send" class="w-5 h-5"></i>
                </button>
            </div>
             <p id="disclaimer-text" class="text-center text-xs text-gray-500 mt-2">Aether AI can make mistakes. Consider checking important information.</p>
        </div>
    </footer>

    <script type="module">
        // Import Firebase modules for database interaction
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getDatabase, ref, onValue, push, set } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";

        // --- ðŸš¨ SECURITY WARNING ---
        // Exposing API keys on the client-side is a major security risk.
        // Anyone can view your website's source code and steal these keys.
        // The Gemini API key, in particular, should be kept secret.
        //
        // SOLUTION: Create a backend service (e.g., a Firebase Cloud Function) to handle the API call.
        // 1. The frontend sends the user's query to your backend service.
        // 2. The backend service adds the secret API key and calls the Gemini API.
        // 3. The backend service returns the response to the frontend.
        //
        // I have replaced your keys with placeholders. You should replace them with your actual keys
        // ONLY for local testing, and implement a backend solution for production.
        
        const firebaseConfig = {
          apiKey: "AIzaSyCICnKBs4Ko8oiOkoB2Jg_QRP8IqqTzmWo",
          authDomain: "bm-ai-agent.firebaseapp.com",
          databaseURL: "https://bm-ai-agent-default-rtdb.firebaseio.com",
          projectId: "bm-ai-agent",
          storageBucket: "bm-ai-agent.appspot.com",
          messagingSenderId: "177012558344",
          appId: "1:177012558344:web:5a0bed843769b90b1d5fbd",
          measurementId: "G-7S5QDYK17"
        };
        
        // This should be moved to a secure backend environment.
        const GEMINI_API_KEY = "AIzaSyCqnzP9H_3c6_V6F1W1UqhMTs7GAZeJETI";
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
        
        // Configuration for the bot's branding and persona
        const botConfig = {
            name: "Blue Minch AI",
            company: "Blue Minch",
            location: "Siliguri",
            avatarUrl: "https://html-generator.com/uploads/images/2025/09/23/36475G8PAZQLZ5Z.png",
        };
        
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        let allFaqs = {}; // Local cache for the FAQ knowledge base
        
        // State management for the chat session
        let sessionState = {
            isGenerating: false,
            streamInterval: null,
        };
        let initialSuggestionsShown = false;

        // Cache DOM elements for quick access
        const elements = {
            chatContainer: document.getElementById('chat-container'),
            chatMessages: document.getElementById('chat-messages'),
            chatInput: document.getElementById('chat-input'),
            sendBtn: document.getElementById('send-btn'),
            welcomeScreen: document.getElementById('welcome-screen'),
            suggestionChips: document.getElementById('suggestion-chips'),
            stopGeneratingContainer: document.getElementById('stop-generating-container'),
            stopGeneratingBtn: document.getElementById('stop-generating-btn'),
        };
        
        // A set of common words to ignore during keyword matching for better search results
        const stopWords = new Set(['a', 'an', 'the', 'is', 'are', 'was', 'were', 'what', 'who', 'when', 'where', 'why', 'how', 'of', 'in', 'on', 'at', 'for', 'to', 'and', 'but', 'or', 'do', 'you', 'me', 'i', 'tell']);
        
        /**
         * Parses a markdown string into safe HTML, with syntax highlighting for code blocks.
         * @param {string} text The markdown text to parse.
         * @returns {string} Sanitized HTML string.
         */
        function parseContent(text) {
            const rawHtml = marked.parse(text || '', {
                gfm: true,
                breaks: true,
                highlight: function(code, lang) {
                    const language = Prism.languages[lang] || Prism.languages.markup;
                    return Prism.highlight(code, language, lang);
                }
            });
            return DOMPurify.sanitize(rawHtml);
        }

        /**
         * Enhances links and lists within a message container with icons and proper attributes.
         * @param {HTMLElement} container The parent element of the message content.
         */
        function enhanceLinks(container) {
            const links = container.querySelectorAll('a');
            links.forEach(link => {
                // Style contact links, but don't add the icon here.
                if (link.href.startsWith('mailto:')) {
                    link.classList.add('contact-link', 'mail-link');
                    link.innerHTML = `<span>${link.innerText}</span>`; // Just wrap text
                } else if (link.href.startsWith('tel:')) {
                    link.classList.add('contact-link', 'phone-link');
                    link.innerHTML = `<span>${link.innerText}</span>`; // Just wrap text
                } else if (link.hostname !== window.location.hostname) {
                     link.classList.add('external-link');
                     link.innerHTML = `<span>${link.innerText}</span><i data-lucide="arrow-up-right" class="w-4 h-4"></i>`;
                     link.target = '_blank';
                     link.rel = 'noopener noreferrer';
                }
            });
            
            // This is the single source of truth for adding the main icon to a list item.
            const listItems = container.querySelectorAll('li');
            listItems.forEach(item => {
                // If an icon is already there, skip.
                if (item.querySelector(':scope > i[data-lucide]')) return;

                const icon = document.createElement('i');
                const textContent = item.textContent.toLowerCase();

                // Determine icon based on link type first, then text content.
                if (item.querySelector('.mail-link')) icon.dataset.lucide = 'mail';
                else if (item.querySelector('.phone-link')) icon.dataset.lucide = 'phone';
                else if (textContent.includes('website')) icon.dataset.lucide = 'globe';
                else icon.dataset.lucide = 'arrow-right-circle';
                
                item.prepend(icon);
            });

            lucide.createIcons();
        }

        function scrollToBottom() { elements.chatContainer.scrollTop = elements.chatContainer.scrollHeight; }
        
        function setGeneratingState(isGenerating) { 
            sessionState.isGenerating = isGenerating; 
            elements.sendBtn.disabled = isGenerating; 
            elements.chatInput.disabled = isGenerating; 
            elements.stopGeneratingContainer.classList.toggle('hidden', !isGenerating); 
        }

        /**
         * Simulates a streaming response by revealing the text word-by-word.
         * @param {HTMLElement} messageContainer The element where the text will be displayed.
         * @param {string} fullText The complete response text from the AI.
         */
        function streamResponse(messageContainer, fullText) {
            setGeneratingState(true);
            const words = fullText.split(' ');
            let wordIndex = 0;
            messageContainer.textContent = '';

            sessionState.streamInterval = setInterval(() => {
                if (wordIndex < words.length) {
                    messageContainer.textContent += (wordIndex > 0 ? ' ' : '') + words[wordIndex];
                    wordIndex++;
                    scrollToBottom();
                } else {
                    stopStreaming(messageContainer, fullText);
                }
            }, 50);
        }

        /**
         * Stops the streaming animation and finalizes the message content.
         * @param {HTMLElement|null} messageContainer The element being updated.
         * @param {string|null} fullText The complete final text.
         */
        function stopStreaming(messageContainer, fullText) {
            if (sessionState.streamInterval) {
                clearInterval(sessionState.streamInterval);
                sessionState.streamInterval = null;
            }
            if (messageContainer && fullText) {
                messageContainer.innerHTML = parseContent(fullText);
                enhanceLinks(messageContainer.closest('.message-group'));
                Prism.highlightAll();
            }
            setGeneratingState(false);
        }

        function addThinkingIndicator() { 
            elements.welcomeScreen.classList.add('hidden'); 
            elements.suggestionChips.classList.add('hidden'); 
            if (elements.chatMessages.querySelector('.thinking-indicator-group')) return; 
            
            const messageGroup = document.createElement('div'); 
            messageGroup.className = 'message-group bot thinking-indicator-group'; 
            messageGroup.innerHTML = `
                <div class="bot-avatar">
                    <img src="${botConfig.avatarUrl}" class="w-full h-full rounded-full" alt="Bot Avatar">
                </div>
                <div class="flex items-center gap-2 bg-white border border-gray-200 px-4 py-2 rounded-full shadow-sm">
                    <div class="typing-indicator"><span></span><span></span><span></span></div>
                    <span class="text-gray-500 text-sm">Thinking...</span>
                </div>
            `;
            elements.chatMessages.appendChild(messageGroup); 
            lucide.createIcons(); 
            scrollToBottom(); 
        }
        
        function removeThinkingIndicator() { 
            const indicator = elements.chatMessages.querySelector('.thinking-indicator-group'); 
            if (indicator) { indicator.remove(); } 
        }

        /**
         * Adds a new message bubble to the chat interface.
         * @param {'user' | 'bot'} sender The sender of the message.
         * @param {string} contentHTML The HTML content of the message.
         * @returns {HTMLElement} The container element for the new message.
         */
        function addMessage(sender, contentHTML) {
            elements.welcomeScreen.classList.add('hidden');
            elements.suggestionChips.classList.add('hidden');
            
            const messageGroup = document.createElement('div');
            messageGroup.className = `message-group ${sender}`;
            
            let avatarHTML = '';
            if (sender === 'bot') {
                avatarHTML = `<div class="bot-avatar"><img src="${botConfig.avatarUrl}" class="w-full h-full rounded-full" alt="Bot Avatar"></div>`;
            }

            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'w-full relative';
            
            const messagesContainer = document.createElement('div');
            messagesContainer.className = 'messages-container flex flex-col w-full';
            messagesContainer.innerHTML = contentHTML;

            contentWrapper.appendChild(messagesContainer);

            if (sender === 'user') {
                 const actionsHTML = `
                    <div class="message-actions">
                        <button class="action-btn copy-message-btn" title="Copy">
                            <i data-lucide="copy" class="w-4 h-4 pointer-events-none"></i>
                        </button>
                    </div>`;
                contentWrapper.innerHTML += actionsHTML;
            }

            messageGroup.innerHTML = avatarHTML;
            messageGroup.appendChild(contentWrapper);
            
            elements.chatMessages.appendChild(messageGroup);
            lucide.createIcons();
            scrollToBottom();
            return messageGroup.querySelector('.messages-container');
        }
        
        function createUserMessageHTML(content) {
             const htmlContent = content.replace(/</g, "&lt;").replace(/>/g, "&gt;");
             return `<div class="message-content">${htmlContent}</div>`;
        }
        
        function createBotMessageHTML(content, blocks) {
            return `<div class="message-content">${content}</div>` + (blocks || '');
        }

        /**
         * Creates HTML for special content blocks like images, buttons, or tables from the DB.
         * @param {object} blockData The block data from Firebase.
         * @returns {string} The corresponding HTML string.
         */
        function createBlockHTML(blockData) {
            switch (blockData.type) {
                case 'image':
                    return `<div class="image-container"><img src="${blockData.url}" alt="Chatbot Image"></div>`;
                case 'button':
                    return `<a href="${blockData.url}" target="_blank" rel="noopener noreferrer" class="content-button"><i data-lucide="link-2" class="w-4 h-4"></i><span>${blockData.text}</span></a>`;
                case 'table':
                    let markdownTable = '';
                    const rows = (blockData.content || '').split('\n').filter(r => r.trim() !== '');
                    if (rows.length > 0) {
                        markdownTable += `| ${rows[0].split(',').map(h => h.trim()).join(' | ')} |\n`;
                        markdownTable += `| ${rows[0].split(',').map(() => '---').join(' | ')} |\n`;
                        rows.slice(1).forEach(rowStr => {
                            markdownTable += `| ${rowStr.split(',').map(c => c.trim()).join(' | ')} |\n`;
                        });
                    }
                    return `<div class="message-content">${parseContent(markdownTable)}</div>`;
                default:
                    return '';
            }
        }

        /**
         * A simple check to see if a query is basic small talk, avoiding unnecessary API calls.
         * @param {string} userText The user's input.
         * @returns {boolean} True if the query is basic.
         */
        function isBasicQuery(userText) {
            const normalizedText = userText.toLowerCase().trim();
            const conversationalKeywords = [ 'hello', 'hi', 'hey', 'how are you', 'good morning', 'good afternoon', 'good evening', 'bye', 'goodbye', 'see you', 'thanks', 'thank you' ];
            if (conversationalKeywords.some(keyword => normalizedText.startsWith(keyword))) return true;
            
            const timeKeywords = ['time', 'date', 'day', 'what is the time', 'what is the date', 'what day is it'];
            if (timeKeywords.some(keyword => normalizedText.includes(keyword))) return true;

            const mathRegex = /^(what is|calculate|compute|solve)?\s*[\d\s\.\+\-\*\/\(\)]+$/i;
            if (mathRegex.test(normalizedText) && normalizedText.match(/[\+\-\*\/]/)) return true;
            
            return false;
        }
        
        /**
         * Calls the Gemini API with context from the database.
         * @param {string} userQuery The user's question.
         * @param {Array} dbContextArray An array of relevant FAQs from the database.
         * @param {number} retries Number of times to retry on failure.
         * @param {number} delay Delay between retries in ms.
         * @returns {Promise<string>} The AI's response text.
         */
        async function callGeminiAPI(userQuery, dbContextArray, retries = 3, delay = 1000) {
            const systemPrompt = `You are ${botConfig.name}, a helpful and friendly AI assistant representing ${botConfig.company}. You are an employee based in our ${botConfig.location} office.
- **Your Persona:** Speak as a representative of the company. Use "we," "our," and "us" when talking about ${botConfig.company}. For example, instead of "At Blue Minch, they offer...", you should say "We offer...".
- Your main goal is to answer the user's question accurately and conversationally, with confidence.
- You are provided with context from our internal knowledge base. Base your answer primarily on this context.
- If the context doesn't fully answer the question, seamlessly integrate your general knowledge to provide a complete and helpful response. Avoid phrases like "according to my knowledge base" or "I couldn't find...".
- If you truly cannot answer the question, politely state that you don't have the information at the moment but that you can ask a human colleague.
- Format your responses using markdown. Use bold, italics, lists, tables, and emojis to make the response engaging.
- IMPORTANT: For emails, use the markdown format [email@example.com](mailto:email@example.com). For phone numbers, use [123-456-7890](tel:1234567890). For websites, use [Website Name](https://example.com).
- **When creating lists, be concise. For example, instead of "You can contact us via email at...", just write "* Email: [contact@blueminch.com](mailto:contact@blueminch.com)".**
- Always be polite and helpful. Handle greetings, small talk, and other conversational questions naturally.
- The current date is ${new Date().toDateString()}.`;

            let contextString = "No relevant context found in the knowledge base.";
            if (dbContextArray && dbContextArray.length > 0) {
                contextString = "Here is some relevant context from our knowledge base:\n\n" + 
                    dbContextArray.map(faq => 
                        `Q: ${faq.question}\nA: ${faq.reply.filter(r => r.type === 'text').map(r => r.content).join('\n')}`
                    ).join('\n\n---\n\n');
            }

            const payload = {
                contents: [{
                    parts: [{
                        text: `CONTEXT:\n${contextString}\n\nUSER'S QUESTION:\n"${userQuery}"`
                    }]
                }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
            };

            try {
                const response = await fetch(GEMINI_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); }

                const result = await response.json();
                const candidate = result.candidates?.[0];

                if (candidate && candidate.content?.parts?.[0]?.text) {
                    return candidate.content.parts[0].text;
                } else {
                    throw new Error("Invalid response structure from Gemini API");
                }
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                if (retries > 0) {
                    await new Promise(res => setTimeout(res, delay));
                    return callGeminiAPI(userQuery, dbContextArray, retries - 1, delay * 2);
                }
                return `I'm sorry, I'm having trouble connecting to my advanced reasoning services right now. Please try again in a moment.`;
            }
        }
        
        /**
         * Searches the local FAQ cache for relevant entries based on the user's text.
         * @param {string} userText The user's input.
         * @param {number} topN The number of top matches to return.
         * @returns {Array<object>} An array of the most relevant FAQ objects.
         */
        function findRelevantFaqs(userText, topN = 1) {
            const normalize = (text) => text.toLowerCase().replace(/[^\w\s']/gi, '').trim();
            const normalizedUserText = normalize(userText);
            const userTokens = new Set(normalizedUserText.split(' ').filter(word => !stopWords.has(word)));
            
            if (userTokens.size === 0) return [];

            const matches = [];

            for (const key in allFaqs) {
                const faq = allFaqs[key];
                
                let searchableText = faq.question || '';
                if (faq.reply && Array.isArray(faq.reply)) {
                    const answerText = faq.reply
                        .filter(r => r.type === 'text' && r.content)
                        .map(r => r.content)
                        .join(' ');
                    searchableText += ' ' + answerText;
                }

                if (searchableText) {
                    const normalizedFaqText = normalize(searchableText);
                    const faqTokens = new Set(normalizedFaqText.split(' ').filter(word => !stopWords.has(word)));
                    const intersection = new Set([...userTokens].filter(x => faqTokens.has(x)));
                    const score = intersection.size / userTokens.size;

                    if (score > 0.1) { // Threshold for a relevant match
                        matches.push({ score, faq: {...faq, key} });
                    }
                }
            }

            matches.sort((a, b) => b.score - a.score);
            return matches.slice(0, topN).map(match => match.faq);
        }

        /**
         * Main logic handler to process user input and generate a bot reply.
         * @param {string} userText The user's input.
         */
        async function findAndDisplayReply(userText) {
            // Handle special command to clear chat
            if (userText.toLowerCase() === 'clear chat' || userText.toLowerCase() === 'reset conversation') {
                elements.chatMessages.innerHTML = ''; 
                elements.welcomeScreen.classList.remove('hidden'); 
                elements.suggestionChips.classList.remove('hidden');
                displayRandomSuggestions();
                setGeneratingState(false);
                removeThinkingIndicator();
                return;
            }

            const relevantFaqs = findRelevantFaqs(userText);
            const bestMatch = relevantFaqs.length > 0 ? relevantFaqs[0] : null;
            
            const geminiResponse = await callGeminiAPI(userText, relevantFaqs);

            removeThinkingIndicator();

            let blocksHTML = '';
            if (bestMatch && bestMatch.reply) {
                blocksHTML = bestMatch.reply
                    .filter(block => block.type !== 'text')
                    .map(createBlockHTML)
                    .join('');
            }

            const finalHTML = createBotMessageHTML('', blocksHTML);
            const messageElContainer = addMessage('bot', finalHTML);
            const streamingTarget = messageElContainer.querySelector('.message-content');
            
            if (streamingTarget) {
                streamResponse(streamingTarget, geminiResponse);
            } else {
                setGeneratingState(false);
            }

            // Log unanswered questions to Firebase for later review
            if (!bestMatch && !isBasicQuery(userText)) {
                const unansweredRef = push(ref(db, 'unansweredQuestions'));
                set(unansweredRef, { question: userText, timestamp: new Date().toISOString() });
            }
        }
        
        /**
         * Handles sending a message, either from input or a suggestion chip.
         * @param {string} [text] Optional text from a suggestion chip.
         */
        function sendMessage(text) {
            const userText = text || elements.chatInput.value.trim();
            if (userText === '' || sessionState.isGenerating) return;
            
            addMessage('user', createUserMessageHTML(userText));
            
            setGeneratingState(true);
            addThinkingIndicator();

            if (!text) {
               elements.chatInput.value = '';
               elements.chatInput.style.height = 'auto';
            }
            findAndDisplayReply(userText);
        }
        
        function displayRandomSuggestions() {
            const allDBQuestions = Object.values(allFaqs).map(faq => faq.question).filter(Boolean);
            if (allDBQuestions.length > 0) {
                 const shuffled = [...new Set(allDBQuestions)].sort(() => 0.5 - Math.random());
                 const selected = shuffled.slice(0, 3);
                 elements.suggestionChips.innerHTML = '';
                 selected.forEach(text => {
                     const button = document.createElement('button');
                     button.className = 'suggestion-chip px-4 py-2 rounded-full text-sm';
                     button.textContent = text;
                     elements.suggestionChips.appendChild(button);
                 });
                 elements.suggestionChips.classList.remove('hidden');
            } else {
                elements.suggestionChips.classList.add('hidden');
            }
        }
        
        /**
         * Applies branding from the botConfig object to the UI.
         */
        function applyBranding() {
            document.getElementById('bot-title').textContent = botConfig.name;
            document.getElementById('welcome-header').textContent = `Welcome to ${botConfig.name}`;
            document.getElementById('disclaimer-text').textContent = `${botConfig.name} can make mistakes. Consider checking important information.`;
            elements.chatInput.placeholder = `Ask ${botConfig.name} anything...`;
            const welcomeLogo = document.getElementById('welcome-logo');
            if (botConfig.avatarUrl) {
                welcomeLogo.src = botConfig.avatarUrl;
            }
        }

        // --- EVENT LISTENERS ---

        elements.sendBtn.addEventListener('click', () => sendMessage());

        elements.chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        elements.chatInput.addEventListener('input', () => {
            elements.chatInput.style.height = 'auto';
            elements.chatInput.style.height = `${elements.chatInput.scrollHeight}px`;
        });

        elements.suggestionChips.addEventListener('click', (e) => {
            if (e.target.tagName === 'BUTTON') sendMessage(e.target.textContent);
        });

        elements.chatMessages.addEventListener('click', (e) => {
            const copyBtn = e.target.closest('.copy-message-btn');
            if (copyBtn) {
                const messageContainer = copyBtn.closest('.messages-container, .message-content');
                
                if (messageContainer) {
                    const textToCopy = messageContainer.innerText;
                    const textArea = document.createElement('textarea');
                    textArea.value = textToCopy;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);

                    copyBtn.innerHTML = `<i data-lucide="check" class="w-4 h-4 text-green-500"></i>`;
                    lucide.createIcons();
                    setTimeout(() => {
                        copyBtn.innerHTML = `<i data-lucide="copy" class="w-4 h-4 pointer-events-none"></i>`;
                        lucide.createIcons();
                    }, 2000);
                }
            }
        });

        elements.stopGeneratingBtn.addEventListener('click', () => stopStreaming(null, null));

        // Listen for real-time updates from the Firebase database
        onValue(ref(db, 'faqs'), (snapshot) => {
            allFaqs = snapshot.val() || {};
            console.log("Firebase FAQs loaded/updated.");
            if (!initialSuggestionsShown) {
                displayRandomSuggestions();
                initialSuggestionsShown = true;
            }
        });
        
        // --- INITIALIZATION ---
        
        applyBranding();
        lucide.createIcons();

    </script>
</body>
</html>






